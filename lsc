#!/usr/bin/perl -w

my $Revision = '1.42';
# File sequence listing tool with compact sequence notation
# Reads input files with file lists or tar output, or 
# calls readdir() on current directory if no options 
# are specified (unless directing STDIN for input)
# Created by Victor E. Vaile, IV on 20080914
# 1.00 20080914 Initial Version
# 1.01 20080923 added feature to traverse subdirs
# 1.02 20081001 added excessive recursion handling
#		added readdir option for stdin
# 1.03 20081007 added $spad for padding frame ->size
# 1.04 20081016 added PreSort() to handle sequence types
#		fix bug in HybridList 's,if ($prev,& ne "",'
# 1.05 20090127 rewrite of ProcessLS() for default behavior
#		automatically recurse directory only results
#		changed sort call locations, add -nopresort
#		made some sort calls conditional
#		broke out WalkDirs() from ProcessLS() 
#		add -skipsort behavior for large sequences
# 1.06 20090203 Pre-PreSort sequences when using dostat as
#		ComputeList is not guaranteed a full seqence
# 1.07 20090212 Added framecount and dirspace options
#		Changed $spad to use $specs for normal output
#		Changed all debug output to use STDERR
#		Add -lf ($lfn $userlfn) option, which forces
#		lastfield type, and allows manual declration
#		for size and sort fields
# 1.08 20090305 Added option for size listed first/last
#		Moved csiz value declarations together
#		Added option for no parenthesis on sizes
#		Fixed printing of fcount for single files
#		Added feature to flag un-recursed directories
# 1.09 20090306 Added sort for hostname syntax
# 1.10 20090311 Added options to right justify output 
#		Added option to sum sizes of frame ranges 
#		(instead of print consistent frame's size)
#		Added option to ignore inconsistent sizes
#		in frame sequences, and list total size for 
#		sequences.
#		Added post-sort by top level domain, then by
#		subdomains... for hostname lists
#		Changed output to save to array instead of 
#		STDOUT initially, for more post-sorting 
#		Broke out formatting of sizes, and handling of
#		right justification line lengths, etc. to 
#		individual subroutines, and created additional
#		hash to track individual frame sizes for 
#		retrieval in non-standard output (-n -l) styles
# 1.11 20090313 Changed print function to more effeciently 
#		calculate field sizes, and print justified 
#		Added sequence count function to re-count s
#		Option to remove padding for right justified 
#		Changed default handling of -ph -p if -z
#		not explicitly specified with -sumcount
# 1.12 20090314 Added match for two extensions on normal seq.
# 1.13 20090530 Added sort by extension number (e.g.: bak001)
#		Added option to suppress duplicate output
#		with -uniq by checking new local %glseen hash
# 1.14 20090603 Added total frames count option -sumtotal
# 1.15 20090609 Changed ProcessFiles() to call FlushList()
#		for single frame sequence instead of parse
#		locally and directly calling AddSpec()
# 1.16 20090609 Added -repack option (implies -uniq) which
#		expands previous lsc output syntax and allows
#		for duplicates to be purged from list
#		Fix for -extnum which was truncating list 
#		values due to non-explicit /$/ in regex
#		Separated GetList() from new AssignList() so
#		LSCunpack() could be called intermediately
# 1.17 20090610 Added -endnum (separate from -extnum), to 
#		separate explicit extensions with numbers 
#		from any digit sequence ending a filename.
#		Changed priority order for sorting sequences
#		to improve match for last digit sequence 
#		prior to final delimeter.
#		Added -unpack option to expand lsc syntax
#		lists for quick expansion commands, etc.
# 1.18 20090704 Added handling for spaces in file names
#		for otherwise normal sequences
# 1.19 20091020	Added skipping of files that begin with a 
#		"._" (dot, underscore), as these tend to
#		be psuedo-resource fork files generated by
#		Macs on non-Mac filesystems (-imac)
# 1.20 20091024	Fix for uninitialized val in pattern match
# 		with whitespace only lines
# 1.21 20091027	Fix for empty dir list. now calls AddSpec()
# 1.22 20091204	Fix for mixed padding in sequences.  Now have
# 		FlushList() separate out hash arrays indexed
# 		by pad value and pass those to FlushFrames()
# 		[previous version of FlushList()] to process.
# 		Changed $size to $psize within FlushFrames()
# 		so as not to corrupt math on $size on separated
# 		differently padded sequences.
# 1.23 20091204	Updated FlushList() to allocate unpadded 
# 		sequences to padded sequences where the value
# 		is the same for both frame sets, and sort the
# 		various sequences by padding value
# 1.24 20100216	Changed FlushFrames() to use $psize (instead of 
# 		$size, which was incorrect, as it failed to use
# 		value from SizeFormat() as it should).
# 		Added -sov (Safe Override Value) to make it easier
# 		than setting slv, sdv, and sfv for large lists.
# 		Changed $maxlenval Default to 80 (prev 70).
# 1.25 20101021 Changed CommaCheck() to use explicit refrence, and
# 		only return a comma (if appropriate), or nothing.
# 		Changed output to not pad single or final column
# 		of data, unless right justifed if $cleanout set
# 		Changed ComputeList() and Dumblist() to explicitly
# 		use an array reference for @framelist
# 		Added Comments to various subroutines.
# 		Fixed scheck processing (Single input line)
# 1.26 20101024 Changed GetSizHashVal() so it could be used 
# 		with compact list notation as well is -n, -l.
# 		and moved totalsize block within compact outpref
# 		of FlushFrames() to use it.
# 		Moved clearing of %sumsizhash to FlushList() to 
# 		fix sumsize output.
# 		Changed SizeFormat() to operate on $psize in 
# 		FlushFrames() (also to fix sumsize output).
# 		Optimized $bsize/$esize assignment in FlushFrames()
# 		Added 'nopack' outpref type, assigned command line
# 		option -nopack, [and unpack] to specify this output
# 		Added Summary  total to totalsize output. Might
# 		change this to be explicitly called later though.
# 1.27 20101028 Changed ShowHelp() output to print in 92 columns.
# 		...Yes, it's a weird number, but a compromise 
# 		Changed -pb to imply -z.
# 		Documented -nopack option in help
# 1.28 20101104 Changed match evaluation in ProcessFiles() and
# 		ProcessDirs() to allow for an exlusion string in
# 		list intputype to change sequence evaluation.
# 		Added option to specify exclusion string This
# 		Allows the script to be used to parse certain
# 		log files with explicit comment strings
# 1.29 20101105 Changed Revision line to variable, and added
# 		Command line option and sub for version display
# 		Changed LSCUnpack() to check for 'list' type
# 		for $userintype and process promiscuously
# 		Changed WARNING to ERROR in RangeCalc() sub
# 1.30 20110118	Added -nolinks, -nodirlinks -showlinks options
# 		Also -linkid -nolinkid for former output control
# 		Changed stats to check for link notation names
# 		in ProcessFiles().  Also catch in ProcessDirs()
# 		Don't die on an unreadable directory, just warn
# 		Keep track of failed dir reads with $fullstat
# 		Added -o $fil option to output text to file
# 		Changed main() to prepend totals to @printarray
# 		Fixed unintentional regex expansion in pattern
# 		match tests for $delem and $lexclude
# 1.31 20110212	Added hash mark '#' to file match for unpack.
# 1.32 20110519	Added hash mark to file match for all names,
# 		as well as parens '()' for all names and unpack.
# 		Isolated default override values for help text.
# 		Changed default safe readdir values.
# 1.33 20110705	Debugging for matches, one last aggressive match
#		for numbers at the end.
# 1.34 20110723	Allowed RangeCalc() to return decrementing ranges
# 1.35 20110803	Aggressive number searching regex as last match.
# 1.36 20111206	Added Invert sub to return Missing frames list
#		Changed handling of non-statable file to warn.
# 1.37 20120628	Added nofiles flag to return only terse tree.
# 1.38 20130125	Changed processing of $tldsort with $nopack to 
#		use compact outpref and  unpack after ProcessTLD
#		Updated readability of regex's for ParseCommandLine
#		Added license output.
# 1.39 20130822	Added ipcheck flag to prefer sorting by IP Address
# 1.40 20130904	Changed $ipcheck to default to 1, and command line
#		flag to negate default behavior.
#		Added -unlimit option to ignore all stat counters
#		for elements in directories encountered.
# 1.41 20170815	Changed test for empty dirs, which previously used
#		defined() on an anonymous array, but the function
#		was depricated for this use on an array, so now 
#		we're using ref(), which seems to work fine.
# 1.42 20171002	Updated Version number for previous change in log.
# 		Moved check for Hostnames in PreSort() and in
# 		ProcessFiles() toward end. Added check for explicit
# 		last chunk of digits before just any digits in 
# 		[same] sort checks as it has been more needed to
# 		identify sequences than the other way around.
# 		Changed -imac to also exclude '.DS_Store' elements.

use strict 'vars';
use strict 'subs';
my @readlist;
my @fileList;
my @framelist;
my @printarray = ();
my $oldDir = "";
my $prefix = "";
my $sep = "";
my $extn = "";
my $size = "";
my $spad = "";
my $userintype = "guess";
my $lastintype = "";
my $outpref = "compact";
my $outstyl = "dircat";
my $expanddirs = 0;
my $blindstat = 0;
my $unlimistat = 0;
my $presort = 1;
my $skipsort = 0;
my $bansorts = 0;
my @lslist;
my $ignorerr = 0;
my $implyfiles = 0;
my $suppressmt = 0;
my $dostat = 0;
my %shash;
my @nicetags = ("B", "K", "M", "G", "T", "P", "E", "Z", "Y");
my $pnice = 0;
my $ponly = 0;
my $lfn = 0;
my $userlfn = 0;
my $defsfn = 4;
my $sfn = $defsfn;
my $usersfn = 0;
my $scheck = 0;
my $relax = 0;
my $quickflag = 0;
my $quickchek = 1;
my $safelstnum = 120;
my $safedirnum = 40;
my $safefilnum = 18;
my ($dsln,$dsdn,$dsfn) = ($safelstnum,$safedirnum,$safefilnum); # in case user changes this before asking for help text
my $sanitycount = 1;
my $sanityctmax = 20;
my $doreaddir = 0;
my $sortcount = 0;
my $countsorts = 0;
my $dirspace = 0;
my $framecount = 0;
my $sizlast = 1;
my $doparens = 1;
my $dirflags = 1;
my $tldsort = 0;
my $tldunpk = 0;
my $rjust = 0;
my $growsprint = 1;
my $lcount = 1;
my $maxlenval = 80;
my $doprint = 1;
my $sumsize = 0;
my $totalsize = 0;
my $runtotlsiz = 0;
my %sumsizhash = ();
my $sumcount = 0;
my %fszhash = ();
my $printsz = 0;
my $isfcsz = 0;
my $dospad = 1;
my $extnum = 0;
my $endnum = 0;
my $douniq = 0;
my $sumtotal = 0;
my $totalcount = 0;
my $repacklsc = 0;
my $unpackonly = 0;
my $imac = 0;
my $cleanout = 1;
my $nopack = 0;
my $invert = 0;
my $lexclude = "";
my $fullstat = 0;
my $nosymtrav = 0;
my $testlinks = 0;
my $nolinks = 0;
my $nofiles = 0;
my $linkid = 0;
my $outfile = "";
my $matchdebug = 0;
my $ipcheck = 1;

sub CommaCheck($) { # Check the ref value, and return a comma if appropriate
	my $cfo = $_[0];
	my $ccspec = "";
	if (! $$cfo) {
		$$cfo = 1;
	} else {
		$ccspec .= ",";
	}
	return $ccspec;
}

sub SortNCount($) { # Tracker/Counter for how many times sort is called...
	$sortcount += 1;
	print STDERR "Sort count: $sortcount\t$_[0]\n";
}

sub ComputeList($) { # Return a condensed spec based on list (array reference)
	my $delta;
	my $cont;
	my $pdelta = 0;
	my $pcont = 0;
	my $prev = 0;
	my $za = "";
	my $zb = "";
	my $fc = 0;
	my $ospec = "";
	my $fo = 0;
	my $framelist = $_[0];
	if ($#$framelist > 0 ) {
		if ($countsorts) { &SortNCount("(ComputeList)");}
		@$framelist = sort { $a <=> $b } @$framelist;
	}
	for my $num (@$framelist) {
		$cont = 0;
		$delta = $num - $prev;
		if ($delta == $pdelta) {
			if ($fc > 1) {
				$cont = 1;
			}
		}
		if ($cont == 0 ) {
			if ($pcont == 0) { # Two 0's in a row, flush 3rd 0 to ouput if present.
				if ($zb ne "") {
					$ospec .= &CommaCheck(\$fo) . "$zb";
					$zb = $za;
				} elsif ($za ne "") {
					$zb = $za;
				} 
				$za = $num;
			} else { # Last num was end of sequence. flush to output.
				if ($zb ne "") {
					$ospec .= &CommaCheck(\$fo) . "$zb-$prev";
					$zb = "";
				} elsif ($za ne "") {
					$ospec .= &CommaCheck(\$fo) . "$za-$prev";
				} else {
					die "Error: miscount!\n";
				}
				if ($pdelta != 1) {
					$ospec .= ":$pdelta";
				}
				$za = $num;
				# A sequence is at least three numbers, so don't let
				# the next delta after a sequence count for a new one yet
				$delta = 0;
			}
		}
		$pdelta = $delta;
		$pcont = $cont;
		$prev = $num;
		$fc += 1;
	} # Done, now flush remaining data
	if ($pcont == 0) { # Last file was standalone.
		if ($zb ne "") {
			$ospec .= &CommaCheck(\$fo) . "$zb,$za";
		} else {
			$ospec .= &CommaCheck(\$fo) . "$za";
		}
	} else { # Last file was the end of a sequence.
		if ($zb ne "") {
			$ospec .= &CommaCheck(\$fo) . "$zb-$prev";
		} elsif ($za ne "") {
			$ospec .= &CommaCheck(\$fo) . "$za-$prev";
		}
		if ($pdelta != 1) {
			$ospec .= ":$pdelta";
		}
	}
	return $ospec;
}

sub DumbList($) { # Return a Simplified condensed spec based on list (array reference)
	my $delta;
	my $prev;
	my $nf;
	my $nl;
	my $fc = 0;
	my $ospec = "";
	my $fo = 0;
	my $framelist = $_[0];
	if ($#$framelist > 0 ) {
		if ($countsorts) { &SortNCount("(DumbList)");}
		@$framelist = sort { $a <=> $b } @$framelist;
	}
	for my $num (@$framelist) {
		if (!$fc) {
			$nf = $num;
			$nl = $num;
		} else {
			$delta = $num - $prev;
			if ($delta == 1 ) {
				$nl = $num;
			} else {
				if ($nf == $nl) {
					$ospec .= &CommaCheck(\$fo) . "$nf";
				} else {
					$ospec .= &CommaCheck(\$fo) . "$nf-$nl";
				}
				$nf = $num;
				$nl = $num;
			}
		}
		$prev = $num;
		$fc += 1;
	}
	if ($nf == $nl) {
		$ospec .= &CommaCheck(\$fo) . "$nf";
	} else {
		$ospec .= &CommaCheck(\$fo) . "$nf-$nl";
	}
	return $ospec;
}

sub HybridList($) { # Identify two consecutive numbers with increment of 1 as a "sequence"
	my $delta;
	my $prev = "";
	my $inspec = $_[0];
	my @list = split(",",$inspec);
	my $ospec = "";
	my $fo = 0;
	for my $val (@list) {
		if ($val =~ /^\d+$/) {
			if ($prev ne "") { # (We don't want to negate a string value of "0".)
				$delta = $val - $prev;
				if ($delta == 1) {
					$ospec .= &CommaCheck(\$fo) . "$prev-$val";
					$prev = "";
				} else {
					$ospec .= &CommaCheck(\$fo) . "$prev";
					$prev = $val;
				}
			} else {
				$prev = $val;
			}
		} else {
			if ($prev ne "") {
				$ospec .= &CommaCheck(\$fo) . "$prev";
			}
			$ospec .= &CommaCheck(\$fo) . "$val";
			$prev = "";
		}
	}
	if ($prev ne "") {
		$ospec .= &CommaCheck(\$fo) . "$prev";
	}
	return $ospec;
}

sub ProcessTLD(\@) { # Reverse sort input array [segments] (separated by '.'), returning array
	my @revlist = ();
	my @outputlist = ();
	for my $lelem (@_) {
		if ($lelem !~ /^$/) { # Empty lines will not work with this post sort
			$lelem =~ s/[ 	]+$//; # kill non-newline white space 
			$lelem = join(".",reverse split(/\./,$lelem));
			push(@revlist,$lelem);
		}
	}
	if ($countsorts) { &SortNCount("(ProcessTLD)");}
	@revlist = sort(@revlist);
	for my $relem (@revlist) {
		$relem = join(".",reverse split(/\./,$relem));
		push(@outputlist,$relem);
	}
	return @outputlist;
}

sub IsValidIP($) { # Quick test to return boolean if string is a valid IP Address
	my $isvalid = 0;
	my $chkstring = $_[0];
	if ($chkstring =~ /^(\d){1,3}(\.(\d){1,3}){3}$/) {
		my @octets = split(/\./,$chkstring);
		my $validoctets = 1;
		for my $octet (@octets) {
			if ($octet > 255) {
				$validoctets = 0;
			}
		}
		$isvalid = $validoctets;
	}
	return($isvalid);
}

sub AddSpec($) { # New AddSpec (Populate %fszhash, Push data to @printarray)
	if ((($_[0] !~ /(\/$)/) || ($outstyl eq "brief")) && ($_[0] !~ /(:$|^$)/) ) { # Count the field sizes
		my $index = 0;
		my @instrings = (split(/\t/,$_[0]));
		while ($index <= $#instrings) {
			my $cmp = length("$instrings[$index]");
			if (! defined($fszhash{$index})) {
				$fszhash{$index} = $cmp;
			} elsif ($cmp > $fszhash{$index}) {
				$fszhash{$index} = $cmp;
			}
			$index += 1;
		}
	}
	push(@printarray,"$_[0]\n");
}

sub FigureSpec() {	# Quick check to determine which field contains the range value
	my $rangefield = 0;
	if ($framecount) { #framecount will be first
		$rangefield = 1;
		if (($printsz) && (defined($fszhash{2})) && (! $sizlast)) { # Count, Size, Range
			$rangefield = 2;
		}
	} elsif (($printsz) && (defined($fszhash{1})) && (! $sizlast)) { # Size, Range
		$rangefield = 1;
	}
	return $rangefield;
}

sub PrintSpec() { # New Print Spec
	my $spitem = "";
	my $ltotal = 0;
	my $rindx;
	my $addval;
	if ($outfile) {
		if (! open(OUTPUT, "> $outfile")) {
			warn "Could not create $outfile\n$!\n";
			$outfile = "";
		}
	}
	for my $keys (sort(keys(%fszhash))) { # Determine how much space we have to work with
		$ltotal += $fszhash{$keys};
		$maxlenval -= 1;	# Because we add spaces in the sprintf between fields
	}
	$maxlenval += 1;		# Because we only add (Fields - 1) spaces
	if ($ltotal > $maxlenval) { # Make Range Field (padding) Smaller
		$addval = $ltotal - $maxlenval;
		$rindx = &FigureSpec();
		while (($fszhash{$rindx} > 1) && ($addval > 0)) {
			$fszhash{$rindx} -= 1;
			$addval -= 1;
		}
	} elsif ((! $growsprint) && ($ltotal < $maxlenval)) { # Make Range Field (padding) Bigger
		$addval = $maxlenval - $ltotal;
		$rindx = &FigureSpec();
		$fszhash{$rindx} += $addval;
	}
	for my $flitem (@printarray) {
		chomp($flitem);
		my @flitems = split(/\t+/,$flitem);
		if ((($flitem !~ /(\/$)/) || ($outstyl eq "brief")) && ($flitem !~ /(:$|^$)/) ) {	# Use the hashed field lengths
			my $idxv = 1;
			my $rjf = "-";
			if (($rjust) && (! defined($flitems[1])) ) { $rjf = ""; } # single field, right justified
			if ((!$rjust) && (! defined($flitems[1])) && ($cleanout) ) { # Don't pad single column of left justified output
				$flitems[0] =~ s/\s+$//;	# Clean padding from spad
				$spitem = sprintf("%s",$flitems[0]);
			} else {
				$spitem = sprintf("%${rjf}$fszhash{0}s",$flitems[0]);
			}
			if ($rjust) { $rjf = ""; }
			while (defined($flitems[$idxv])) {
				if ((!$rjust) && (! defined($flitems[$idxv + 1])) && ($cleanout)) { # Don't pad final column of left justified output
					$flitems[$idxv] =~ s/\s+$//;	# Clean padding from spad
					$spitem .= sprintf(" %s",$flitems[$idxv]);
				} else {
					$spitem .= sprintf(" %${rjf}$fszhash{$idxv}s",$flitems[$idxv]);
				}
				$idxv += 1;
			}
		} else {
			$spitem = $flitem;
		}
		if ($outfile) {
			print OUTPUT "$spitem\n";
		} else {
			print STDOUT "$spitem\n";
		}
	}
	if ($outfile) {
		close(OUTPUT);
	}
}

sub SequenceCount($) {	# Return the number of frames in a sequence
	my $rtval = 0;
	my $ofst = 1;
	my @nums = split(/[:-]/,$_[0]);
	my $cnum;
	if (defined($nums[2])) {
		$ofst = $nums[2];
	}
	if (defined($nums[1])) {
		$cnum = $nums[0];
		while ($cnum <= $nums[1]) {
			$rtval += 1;
			$cnum += $ofst;
		}
	} elsif (defined($nums[0])) {
		$rtval += 1;
	}
	return $rtval;
}

sub GetSizHashVal($) {	# Get the size values for frames in a -n or -l output from the hash
	my $rtval = 0;
	for my $specs (split(",",$_[0])) { # Get it from compact list as well...
		my $ofst = 1;
		my @nums = split(/[:-]/,$specs);
		my $lena;
		my $dopad = 0;
		my $cnum;
		my $shindex;
		if (defined($nums[2])) {
			$ofst = $nums[2];
		}
		if (defined($nums[1])) {
			$lena = length($nums[0]); # Always pad to the beginning value's string length 
			$cnum = $nums[0];
			while ($cnum <= $nums[1]) {
				$cnum = sprintf("%${lena}.${lena}d",$cnum);
				$shindex = "${prefix}${sep}${cnum}${extn}";
				if (defined($sumsizhash{$shindex})) {
					$rtval += $sumsizhash{$shindex};
				} else {
					die "\nCan't find $shindex = \$sumsizhash{$shindex}\n(NUMS:\t$cnum/$nums[1])\n\n";
				}
				$cnum += $ofst;
			}
		} elsif (defined($nums[0])) {
			$shindex = "${prefix}${sep}$nums[0]${extn}";
			if (defined($sumsizhash{$shindex})) {
				$rtval += $sumsizhash{$shindex};
			} else {
				die "\nCan't find $shindex = \$sumsizhash{$shindex}\n(NUMS:$nums[0])\n\n";
			}
		} else {
			die "ERROR GetSizHashVal: No value found in: $_[0]\n";
		}
	}
	return $rtval;
}

sub NicePrint($$) { # Return Human Tagged format string for size using Global @nicetags array
	my %nth;
	my $out;
	my $count = 0;
	my $mnum = $_[0];
	if ($_[1]) {	# If there's a tag, count down from there...
		for (0..$#nicetags) {	# Index the nicetags array
			$nth{$nicetags[$_]} = "$_";
		}
		$count = $nth{$_[1]};
	}
	if ( $mnum =~ /-/ ) {	# Not dividing Negative values
		$mnum =~ s/-//g;
		print STDERR "Warning:\tNegative value '-$mnum' switched to positive.\n";
	}
	while ( $mnum >= 1024) {
		$mnum = sprintf("%.9f", $mnum/1024 );
		$count += 1;
	}
	if ($mnum < 10) {
		$out = sprintf("%.1f", $mnum );
	} else {
		$out = sprintf("%.0f", $mnum );
	}
	return "${out}$nicetags[$count]"
}

sub SizeFormat($) { # Add text formatting to suplied string, returning output
	my $csiz = $_[0];
	if ($pnice) {
		my $ncsiz = &NicePrint($csiz);
		if (($ponly) || ($isfcsz)) {
			$csiz = "$ncsiz";
		} else {
			$csiz = "$csiz [$ncsiz]";
		}
	}
	if (($doparens) && (! $isfcsz)) {
		$csiz = "($csiz)";
	}
	return $csiz;
}

sub FrameInvert(@) { # Return a list of frames not existing within the given range based on highest and lowest value
	my @inlist = @_; # Ranges fed to this sub must not mix pad levels as duplicate numeric values will fail (so call between FlusList() and FlushFrames().
	if (! $#inlist) {
		return();
	} else {
		@inlist = sort {$a <=> $b} (@inlist);
	}
	my %exist = ();
	my $pcurrent;
	my @fioutlist = ();
	my $first = $inlist[0];
	my $rsiz = $#inlist + 1; 
	my $last = $inlist[$#inlist];
	my $plen = length($first);
	for my $hv (@inlist) {
		my $hrawval = $hv + 0; # Force to non-padded value
		if (defined($exist{$hrawval})) {
			die "ERROR:  $hv Defined already in existing hash\n";
		}
		$exist{$hrawval} = "$hv";
	}
	my $current = $first + 0; # Force value to non-padded
	while ($current  <= $last ) {
		if (! defined($exist{$current})) { # Create a proper padded value for the missing element
			$pcurrent = sprintf("%${plen}.${plen}d",$current);
			push(@fioutlist,$pcurrent);
		}
		$current += 1;
	}
	return(@fioutlist);
}

sub FlushList() {	# Separate out differently padded sequences...
	my %padhash = ();
	my @nonpads = ();
	my $upsam = 1;
	my $uplen = 0;
	my $plen = 0;
	my $nlen = 0;
	for my $fram (@framelist) {
		if ($fram =~ /^0/) {	#Padded Entry
			my $plen = length($fram);
			push(@{ $padhash{"${plen}"} },$fram);
		} else {
			if ($upsam) {
				$nlen = length($fram);
				if (($uplen) && ($nlen != $uplen)) {
					$upsam = 0;
				}
				$uplen = $nlen;
			}
			push(@nonpads,$fram);
		}
	}
	if (($uplen) && ($upsam)) {
		push(@{ $padhash{"$uplen"} }, @nonpads);
	} elsif ($uplen) {
		my @leftovers = ();
		for my $npfram (@nonpads) {	# Allocate non-pads to appropriate existing padded arrays
			my $nplen = length($npfram);
			if (defined($padhash{"${nplen}"})) {
				push(@{ $padhash{"${nplen}"} },$npfram);
			} else {
				push(@leftovers,$npfram);
			}
		}
		if (@leftovers) {	# Find the length of the least significant value (for key index)
			@leftovers = sort(@leftovers);
			my $npalen = length($leftovers[0]);
			@{ $padhash{"${npalen}nopad"} } = @leftovers;
		}
	}
	for my $sequence (sort keys %padhash ) {
		if (@{$padhash{$sequence}}) {
			@framelist = @{$padhash{$sequence}};
			if ($invert) {
				@framelist = &FrameInvert(@framelist);
			}
			if ((@framelist) || (! $invert)) { # Data in the list or non-invert emtpy list
				&FlushFrames;
			} else { # FrameInvert() returned empty list
				@framelist = ();
			}
		}
	}
	%sumsizhash = ();
}

sub FlushFrames() {
	my $rangespec;
	my $fspec = "";
	my $dp = ""; 
	my $bsize = "";
	my $esize = "";
	my $osize = $size;
	my $psize = $size;
	if (($outstyl eq "brief") && ($oldDir !~ /^$/)) {
		$dp .= "$oldDir/";
	}
	if (($dostat) && ($size !~ /^$/)) {	# Don't pad size if it doesn't have a value
		if ($sumsize) {
			my $lastcount = $#framelist + 1;
			$psize *= $lastcount;
		}
		$psize = &SizeFormat($psize);
		if ($printsz) {
			if ($sizlast) {
				$esize = "\t${psize}";
			} else {
				$bsize = "${psize}\t";
			}
		}
	}
	if ($outpref eq "nopack") { # Print Unpacked List
		my $fcount = "";
		for my $unpacked (sort {$a <=> $b} (@framelist)) {
			if (($dostat) && ($size !~ /^$/)) {	# Don't pad size if it doesn't have a value
				my $shindex = "${prefix}${sep}$unpacked${extn}";
				if (! defined($sumsizhash{$shindex})) {
					die "Could not find index $shindex in \$sumsizhash\n";
				}
				my $stsize = $sumsizhash{$shindex};
				$stsize = &SizeFormat($stsize);
				if ($printsz) {
					if ($sizlast) {
						$esize = "\t$stsize";
					} else {
						$bsize = "$stsize\t";
					}
				}
			}
			$fspec = "${fcount}${bsize}${dp}${prefix}${sep}${unpacked}${extn}${esize}";
			&AddSpec("${fspec}");
		}
	} elsif ($outpref eq "compact") {
		my $fcount = "";
		if ($framecount) {
			my $lastcount = $#framelist + 1;
			if ($sumtotal) {
				$totalcount += $lastcount;
			}
			if ((! $totalsize) && ($sumcount) && ($dostat) && ($psize !~ /^$/)) {
				$isfcsz = 1;
				$osize = &SizeFormat($osize);
				$isfcsz = 0;
				$lastcount .= "/$osize";
			}
			if ($doparens) {
				$fcount = "($lastcount)\t";
			} else {
				$fcount = "$lastcount\t";
			}
		}
		$rangespec = &ComputeList(\@framelist);
		if ($relax) {
			$rangespec = &HybridList($rangespec);
		}
		if ($totalsize) { # Get real total size of this spec.
			my $stsize = &GetSizHashVal($rangespec);
			$stsize = &SizeFormat($stsize);
			if ($sizlast) {
				$esize = "\t$stsize";
			} else {
				$bsize = "$stsize\t";
			}
		}
		if ($rangespec =~ /[-,]/) { # Only print brackets for multiple frames
			$fspec = "${fcount}${bsize}${dp}${prefix}${sep}\[${rangespec}\]${extn}${esize}";
		} else {
			if ($dospad) {
				$spad = " " x (length($rangespec) + 3);
			}
			$fspec = "${fcount}${bsize}${dp}${prefix}${sep}${rangespec}${extn}${spad}${esize}";
		}
		&AddSpec("${fspec}");
	} else { # (normal)
		if ($outpref eq "normal") {
			$rangespec = &DumbList(\@framelist);
		} else { # (long)
			$rangespec = &ComputeList(\@framelist);
			if ($relax) {
				$rangespec = &HybridList($rangespec);
			}
		}
		for my $specs (split(",",$rangespec)) {
			my $fcount = "";
			if ((($totalsize) || ($sumsize)) && ($printsz) && ($psize !~ /^$/) ) { # Get the size for this range from the %sumsizhash
				my $stsize = &GetSizHashVal($specs);
				$stsize = &SizeFormat($stsize);
				if ($sizlast) {
					$esize = "\t$stsize";
				} else {
					$bsize = "$stsize\t";
				}
			}
			if ($framecount) {
				$fcount = &SequenceCount($specs);
				if ($sumtotal) {
					$totalcount += $fcount;
				}
				if ((! $totalsize) && ($sumcount) && ($dostat) && ($psize !~ /^$/)) {
					$isfcsz = 1;
					my $losize = &SizeFormat($osize); # Don't change $osize in the for() loop
					$isfcsz = 0;
					$fcount .= "/$losize";
				}
				if ($doparens) {
					$fcount = "($fcount)\t";
				} else {
					$fcount = "$fcount\t";
				}
			}
			if ($specs =~ /-/) {
				$fspec = "${fcount}${bsize}${dp}${prefix}${sep}\[${specs}\]${extn}${esize}";
			} else {
				if ($dospad) {
					$spad = " " x (length($specs) + 3);
				}
				$fspec = "${fcount}${bsize}${dp}${prefix}${sep}${specs}${extn}${spad}${esize}";
			}
			&AddSpec("${fspec}");
		}
	}
	@framelist = ();
}

sub PreSort(@) {
	# This is just a quick pre-sort for mixed sequences.
	# We only have to sort sequences with extension by extension here,
	# and separate the groups.  We don't have to call sort <=> on the
	# resulting lists, as they will all be sorted by the ComputeList()
	# and DumbList() functions later.
	my @numsonly = ();
	my @numwords = ();
	my @anyothrs = ();
	my @srtdlist = ();
	my %madhash = ();
	my $madkeys;
	while (my $slitem = shift(@_)) {
		if (($endnum) && ($slitem =~ /^([-\w#()\.]+)(\D)(\d+)$/)) {
			push(@{ $madhash{"${1}${2}"} },$slitem);	# Any digits at the end of filename (name_stuff000) 
		} elsif (($extnum) && ($slitem =~ /^([-\w#()\.]+\.[a-zA-z]+)(\d+)(\>\>\>\d*){0,1}$/)) {
			push(@{ $madhash{"${1}"} },$slitem);		# Explicit extension numbering (name.stuff.bak000) 
		} elsif ($slitem =~ /^(\d+)(\>\>\>\d*){0,1}$/) {
			push(@numsonly,$slitem);			# Frame numbers only (0000)
		} elsif ($slitem =~ /^(\d+)\.(\w+)(\>\>\>\d*){0,1}$/) {
			push(@numwords,$slitem);			# Frame numbers with extension (0000.ext)
		} elsif (($ipcheck) && ($slitem =~ /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.\d{1,3}$/)) {
			my ($a,$b,$c) = ($1,$2,$3);
			$a = sprintf("%3.3d",$a);
			$b = sprintf("%3.3d",$b);
			$c = sprintf("%3.3d",$c);
			push(@{ $madhash{"${a}${b}${c}"} },$slitem);	# Explicit IP Addresses (No Sizes, padding all octets for sorting)
		} elsif ($slitem =~ /^([-\w#()\.\s]+)([\._-]{1})(\d+)\.(\w+)(\>\>\>\d*){0,1}$/) {
			push(@{ $madhash{"${1}/-/${4}"} },$slitem);	# Normal Frame sequence (name.0000.ext)
		} elsif ($slitem =~ /^([-\w#()\.\s]+)([\._-]{1})(\d+)\.(\w+)\.(\w+)(\>\>\>\d*){0,1}$/) {
			push(@{ $madhash{"${1}/-/${4}${5}"} },$slitem);	# Frame sequence /w extra extension (name.0000.ext.ext)
		} elsif ($slitem =~ /^([-\w#()\.\s]+[^\d])(\d+)\.(\w+)(\>\>\>\d*){0,1}$/) {
			push(@{ $madhash{"${1}/${3}"} },$slitem);	# Sequences without prefix/num separator (name0000.ext)
		} elsif ($slitem =~ /^(\D+)(\d+)(\>\>\>\d*){0,1}$/) {
			push(@{ $madhash{"${1}/-/ZNothing"} },$slitem);	# Any non-digit[s] followed by digits (name000,_000)
		} elsif ($slitem =~ /^(.*)(\D+)(\d+)(\D+)(\>\>\>\d*){0,1}$/) {
			push(@{ $madhash{"${1}${2}/-/${4}"} },$slitem);	# Any last chunk of digits, then other stuff (name00-001-thing.ext)
		} elsif ($slitem =~ /^([-\._A-Za-z]+)(\d+)([-\._A-Za-z]+)([-\w\.]+)$/) {
			push(@{ $madhash{"${1}/${3}${4}"} },$slitem);	# Hostnames (...Semistrict)
		} elsif ($slitem =~ /^(\D+)(\d+)(.*)(\>\>\>\d*){0,1}$/) {
			push(@{ $madhash{"${1}/-/${3}"} },$slitem);	# Any non-digit[s] followed by digits, then other stuff (name-000-thing.ext)
		} else {
			push(@anyothrs,$slitem);			# Anything else.
		}
	}
	if (($dostat) && (($lastintype =~ /^(tar|ll)$/) || (($usersfn) && ($lastintype =~ /^lastfield$/)) )) {		# We do have to pre-sort here...
		if ($countsorts) { &SortNCount("(PreSort [numsonly])");}
		@numsonly = map  { $_->[1] }
			    sort { $a->[0] <=> $b->[0] }
			    map  { [ /^(\d+)\>\>\>\d*$/, $_ ] }
			    @numsonly;
	}
	push(@srtdlist,@numsonly);
	if ($#numwords > 0 ) {
		if ($countsorts) { &SortNCount("(PreSort [numwords])");}
		if (($dostat) && (($lastintype =~ /^(tar|ll)$/) || (($usersfn) && ($lastintype =~ /^lastfield$/)) )) {
			# I think the %dirlist hash that fed ProcessFiles already sorted the list (kind of). but, 
			# we can't guarantee that it's sorted, and with $dostat set, ComputeList won't necessarily be
			# fed a whole sequence to sort, so we'll have to sort it here. Also the map is different
			# anyway with the '>>>' separators.
			@numwords = map  { $_->[2] }
				    sort { $a->[0] <=> $b->[0] || $a->[1] cmp $b->[1] }
				    map  { [ /(\d+)\.(\w+)\>\>\>\d*$/, $_ ] }
				    @numwords;
		} else {
			@numwords = map  { $_->[1] }
				    sort { $a->[0] cmp $b->[0] }
				    map  { [ /\.(\w+)$/, $_ ] }
				    @numwords;
		}
	}
	push(@srtdlist,@numwords);
	# Crazy way to keep normal sequences ordered by prefix,
	# and still separated by extension.  We use separators
	# that will not exist in actual file names ('/','/-/').
	$madkeys = keys(%madhash);
	if ($madkeys > 1 ) {
		if ($countsorts) { &SortNCount("(PreSort [madhash])");}
		if (($dostat) && (($lastintype =~ /^(tar|ll)$/) || (($usersfn) && ($lastintype =~ /^lastfield$/)) )) {
			for my $prepost ( sort keys %madhash ) {
				if ($#{$madhash{$prepost}} > 0) {
					if ($countsorts) { &SortNCount("(PreSort [madhash: $prepost])");}
					@{$madhash{$prepost}} = map  { $_->[1] }
								sort { $a->[0] <=> $b->[0] }
								map  { [ /(\d+)\.\w+\>\>\>\d*$/, $_ ] }
								@{$madhash{$prepost}};
					push(@srtdlist,(@{$madhash{$prepost}}));
				}
			}
		} else {
			for my $prepost ( sort keys %madhash ) {
				push(@srtdlist,(@{$madhash{$prepost}}));
			}
		}
	} else {
		for my $prepost ( keys %madhash ) {
			if (($dostat) && (($lastintype =~ /^(tar|ll)$/) || (($usersfn) && ($lastintype =~ /^lastfield$/)) ) && ($#{$madhash{$prepost}} > 0)) {
				if ($countsorts) { &SortNCount("(PreSort [madhash: $prepost])");}
				@{$madhash{$prepost}} = map  { $_->[1] }
							sort { $a->[0] <=> $b->[0] }
							map  { [ /(\d+)\.\w+\>\>\>\d*$/, $_ ] }
							@{$madhash{$prepost}};
			}
			push(@srtdlist,(@{$madhash{$prepost}}));
		}
	}
	if ($#anyothrs > 0 ) {
		if ($countsorts) { &SortNCount("(PreSort [anyothrs])");}
		@anyothrs = sort(@anyothrs);
	}
	push(@srtdlist,@anyothrs);
	return @srtdlist;
}

sub ProcessFiles(@) {
	my $snum;
	my $match;
	my $hasfiles = 0;
	my $anymatch = 0;
	@framelist = ();
	if ($skipsort) {
		@fileList = @_;
	} else {
		if ($presort) {
			@fileList = &PreSort(@_);
		} else {
			if ($countsorts) { &SortNCount("(ProcessFiles [noPreSort])");}
			@fileList = sort(@_);
		}
	}
	if (($outstyl eq "dircat") && ($oldDir !~ /^$/)) {
		if ((! $suppressmt) || (@fileList != 0)) {
			&AddSpec("${oldDir}:");
		}
	}
	my $started = 0;
	while (my $item = shift(@fileList)) {	
		$hasfiles += 1;
		$match = 1;
		my ($cpre, $csep, $snum, $cext, $csiz) = ("", "", "", "", "");
		my $fcount = "";
		if ($dostat) {
			if (($lastintype =~ /^(tar|ll)$/) || (($usersfn) && ($lastintype =~ /^lastfield$/)) ) {
				my @ifs = split /\>\>\>/,$item; # Horrible hack to treat a scalar like an array
				$item = $ifs[0];
				if ($ifs[1]) {
					$csiz = $ifs[1];
				}
			} elsif ($lastintype eq "ls") {
				my $statdir = $oldDir;
				if ($statdir =~ /^$/) {
					$statdir = ".";
				}
				my $stnam = "${statdir}/${item}";
				if (($nosymtrav) || ($nolinks) || ($testlinks)) { # Don't match links if we've never tagged them.
					if ($item =~ /^(.*) \(->\)/) { # Catch symlink references here and stat the proper files/dirs
						$stnam = "${statdir}/${1}";
					} elsif ($item =~ /^(.*) -> /) {
						$stnam = "${statdir}/${1}";
					}
				}
				if (my @fstat = stat("${stnam}")) { # Assign as per usual
					$csiz = $fstat[7];
				} else { # Warn, and keep going...
					print STDERR "Could not stat ${stnam}: $!\n";
					$csiz = 0;
				}
			}
		}
		if (($imac) && (($item =~ /^\._/) || ($item =~ /^.DS_Store$/))) { # Do not pass go, do not collect $200
			$match = 2; # Match nothing...
			$csiz = "";
			if ($started) { # Flush the list and pretend this doesn't exist...
				&FlushList();
				$started = 0;
			}
		} elsif (($userintype =~ /^list$/) && (($lexclude !~ /^$/) && ($item =~ /\Q$lexclude\E/))) {	# Explicitly don't count this item as a match
			$match = 0;
			$anymatch += 1;
		} elsif (($endnum) && ($item =~ /^([-\w#()\.\s]+)(\D)(\d+)$/)) {				# Digits at the end of a filename (name.stuff_000) [priority]
			$cpre	= "$1$2";
			$snum	= $3;
			$anymatch += 1;
		} elsif (($extnum) && ($item =~ /^([-\w#()\.\s]+\.[a-zA-z]+)(\d+)$/)) {				# Extension numbering (name.stuff.bak000) [priority]
			$cpre	= $1;
			$snum	= $2;
			$anymatch += 1;
		} elsif (($ipcheck) && ($item =~ /^(\d+\.\d+\.\d+)(\.)(\d+)$/) && (&IsValidIP($item))) {	# Matching for IP Addresses
			$cpre	= $1;
			$csep	= $2;
			$snum	= $3;
			$anymatch += 1;
		} elsif ($item =~ /^([-\w#()\.\s]+)([\._-]{1})(\d+)\.(\w+)$/) {					# Normal Frame sequence (name.0000.ext)
			$cpre	= $1;
			$csep	= $2;
			$snum	= $3;
			$cext	= "\.$4";
			$anymatch += 1;
		} elsif ($item =~ /^([-\w#()\.\s]+)([\._-]{1})(\d+)\.(\w+)\.(\w+)$/) {				# Frame sequence /w extra extension (name.0000.ext.ext)
			$cpre	= $1;
			$csep	= $2;
			$snum	= $3;
			$cext	= "\.$4\.$5";
			$anymatch += 1;
		} elsif ($item =~ /^(\d+)$/) {									# Frame numbers only (0000)
			$snum	= $1;
			$anymatch += 1;
		} elsif ($item =~ /^(\d+)\.(\w+)$/) {								# Frame numbers with extension (0000.ext)
			$snum	= $1;
			$cext	= "\.$2";
			$anymatch += 1;
		} elsif ($item =~ /^([-\w#()\.\s]+\D)([\d]+)([-_\.])([\w]+)$/) {				# Last digit sequence before final delimeter (name2ab_0001.ext)
			$cpre	= $1;
			$snum	= $2;
			$cext	= "$3$4";
			$anymatch += 1;
		} elsif ($item =~ /^([-\w#()\.\s]+)([\._-]{1})(\d+)$/) {					# Frame name with numbers (name.0000)
			$cpre	= $1;
			$csep	= $2;
			$snum	= $3;
			$anymatch += 1;
		} elsif ($item =~ /^([-\w#()\.\s]+[\D])(\d+)\.(\w+)$/) {					# Frame sequence with ext, no sep (name0000.ext)
			$cpre	= $1;
			$snum	= $2;
			$cext	= "\.$3";
			$anymatch += 1;
			$anymatch += 1;
		} elsif ($item =~ /^([-\w#()\.\s]+[-\._A-Za-z])(\d+)$/) {					# Frame name and numbers, no sep (name0000)
			$cpre	= $1;
			$snum	= $2;
			$anymatch += 1;
		} elsif ($item =~ /^([-\w#()\.\s]+)(\D)(\d+)$/) {						# End of name numbering (name.stuff.bak000) [leftovers]
			$cpre	= "$1$2";
			$snum	= $3;
			$anymatch += 1;
		} elsif ($item =~ /^(\D+)(\d+)$/) {								# End of name numbering (name000|_000) [leftovers]
			$cpre	= "$1";
			$snum	= $2;
			$anymatch += 1;
		} elsif ($item =~ /^(.*)(\D+)(\d+)(\D+)$/) {					# Last chunk of numbers in a file name (name_113_20170926_am_000001bit.dpx)
			$cpre	= "${1}${2}";
			$snum	= $3;
			$cext	= $4;
			$anymatch += 1;
		} elsif ($item =~ /^([-\._A-Za-z]+)(\d+)([-\._A-Za-z]+)([-\w\.]+)$/) {				# Hostnames (...Semistrict)
			$cpre	= $1;
			$snum	= $2;
			$cext	= "${3}${4}";
			$anymatch += 1;
		} elsif ($item =~ /^(\D+)(\d+)(.*)$/) {								# First number of name numbering (name000|_000)
			$cpre	= "$1";
			$snum	= $2;
			$cext	= $3;
			$anymatch += 1;
		} else {
			$match = 0;
		}
		if ($match == 0 ) {
			if ($started) {
				&FlushList();
				$started = 0;
			}
			if ($framecount) {
				if ($sumtotal) {
					$totalcount += 1;
				}
				if ($doparens) {
					$fcount = "(1)\t";
				} else {
					$fcount = "1\t";
				}
			}
			my $printspec = "${fcount}";
			if ($csiz !~ /^$/) { $runtotlsiz += $csiz; } # Add csiz to big running total
			if (($printsz) && ($csiz !~ /^$/)) {
				$csiz = &SizeFormat($csiz);
			}
			if (($printsz) && (! $sizlast)) {
				if ($csiz !~ /^$/ ) {	# Don't pad size if it doesn't have a value
					$csiz = "${csiz}\t";
				}
				$printspec .= "${csiz}";
			}
			if (($outstyl eq "brief") && ($oldDir !~ /^$/)) {
				$printspec .= "$oldDir/";
			}
			$printspec .= "${item}";
			if (($printsz) && ($sizlast)) {
				$printspec .= "\t${csiz}";
			}
			if (($dostat) && ($nopack)  && ($csiz !~ /^$/)) { # Set the size for this range in the %sumsizhash
				$sumsizhash{$item} = $csiz;
			}
			if (! $invert) { # If it's not a match for a sequence, skip as we're Only listing missing files
				&AddSpec("${printspec}");
			}
		}
		if ($match == 1) { # Process file name
			if ($csiz !~ /^$/) { $runtotlsiz += $csiz; } # Add csiz to big running total
			if ( ($started) && ($cpre eq $prefix) && ($cext eq $extn) && ($csep eq $sep) && (($csiz eq $size) || ($totalsize) || ($nopack)) ) {
				# The sequence continues
				push(@framelist,$snum);
				if ($dostat && (($totalsize) || ($sumsize) || ($nopack)) && ($csiz !~ /^$/)) { # Set the size for this range in the %sumsizhash
					$sumsizhash{$item} = $csiz;
				}
				if ( @fileList == 0 ) { # final frame in sequence
					&FlushList();
				}
			} else { # A new frame sequence
				if ($started) {
					&FlushList();
					$started = 0;
				}
				if ($dostat && (($totalsize) || ($sumsize) || ($nopack)) && ($csiz !~ /^$/)) { # Set the size for this range in the %sumsizhash
					$sumsizhash{$item} = $csiz;
				}
				# process the new sequence
				$prefix	= $cpre;
				$sep	= $csep;
				$extn	= $cext;
				$size	= $csiz;
				if ( @fileList == 0 ) { # Only file in list
					push(@framelist,$snum);
					&FlushList();
				} else {
					push(@framelist,$snum);
					$started = 1;
				}
			}
		}
	}
	if ($matchdebug) {
		if (!$anymatch) { # DEBUG
			print STDOUT "No matches found at all!\n";
		} else {
			print STDOUT "$anymatch matches found\n";
		}
	}
	if ( ($outstyl eq "dircat") &&  (($hasfiles != 0) || ($dirspace)) ) {
		push(@printarray,"\n");
	}
}

sub ProcessDirs(\@) {
	my %dirlist;
	my $dir;
	my $file;
	my $lsiz;
	my @parts;
	my @tmpar;
	for my $lin (@_) {
		my $ds = "";
		if (($dostat) && (($lastintype =~ /^(tar|ll)$/) || (($usersfn) && ($lastintype =~ /^lastfield$/)) )) {
			my @lfs = split /\>\>\>/,$lin; # Horrible hack to treat a scalar like an array
			$lin = $lfs[0];
			$lsiz = $lfs[1];
		}
		#if ((defined($lin)) && ($lin !~ /^[\s]*$/ )) { # Might need this one later...
		if ($lin !~ /^$/ ) {
			if ($lin =~ /\/\/$/) {	# Flag a un-recursed directory:
				$lin =~ s/\/\/$//g;
				if ($dirflags) {
					$ds = "/";
				}
			} #if ($lin =~ /\/$/) {
			if (($lin =~ /\/$/) && (($userintype !~  /^list$/) || ($lexclude =~ /^$/))) {
				@parts = split /\//,$lin;
				$dir = join "/",@parts;
				if (! defined $dirlist{$dir} ) {
					$dirlist{$dir} = ();
				}
			} else {
				if (($userintype =~ /^list$/) && (($lexclude !~ /^$/) && ($lin =~ /\Q$lexclude\E/))) {	# Keep this whole line together 
					$file = "${lin}${ds}";
					$dir = "";
				} elsif ($lin =~ /(.*)\/([^\/]+->.*)/) { # Handle symlink notation.
					$file = $2;
					$dir = $1;
				} else {
					@parts = split /\//,$lin;
					$file = pop(@parts);
					$file = "${file}${ds}";
					$dir = join "/",@parts;
				}
				if (($dostat) && (($lastintype =~ /^(tar|ll)$/) || (($usersfn) && ($lastintype =~ /^lastfield$/)) )) {
					push(@{ $dirlist{$dir} },"$file>>>$lsiz"); # Horrible hack to treat a scalar like an array
				} else {
					push(@{ $dirlist{$dir} },$file);
				}
			}
		}
	}
	if ($countsorts) { &SortNCount("(ProcessDirs [\%dirlist keys])");}
	for my $thisDir ( sort keys %dirlist ) {
		$oldDir = $thisDir;
		# Compact Empty Dirs:
		if (ref($dirlist{$thisDir}) ne "ARRAY") {
			push(@tmpar,"$thisDir/");
		}
		&ProcessFiles(@{$dirlist{$thisDir}});
	}
	if ((@tmpar != 0 ) && ($outstyl eq "brief") && (! $suppressmt)) {
		$oldDir = "";
		&ProcessFiles(@tmpar);
	}
}

sub RunLS(;$) {
	my $lsdir = $_[0];
	my $dirpre;
	my @rlsout;
	if (! defined $lsdir) {
		$lsdir = ".";
		$dirpre = "";
	} else {
		$dirpre = "$lsdir/";
	}
	if (! opendir(LSOUT, "$lsdir")) {
		warn "\nWARNING:\nWARNING: Could not open $lsdir: $!\nWARNING:\n";
		if ($fullstat < 248 ) { $fullstat += 8; } # Increment an error status > 248 = unknown num read failures...
		push(@rlsout,"$dirpre");
		return @rlsout;
	}
	while (defined(my $lslin = readdir(LSOUT)) ) {
		chomp($lslin);
		if (($lslin ne '.') && ($lslin ne '..')) {
			push(@rlsout,"${dirpre}${lslin}");
		}
	}
	closedir(LSOUT);
	if (! @rlsout) { # We didn't read anything from the directory.  Send it back with a '/' on the end.
		push(@rlsout,"$dirpre");
	}
	if ($dostat) {	# ComputeList won't necessarily have a chance to sort this...
		if ($#rlsout > 0 ) {
			if ($countsorts) { &SortNCount("(RunLS [rlsout])");}
			@rlsout = sort(@rlsout);
		}
	}
	return @rlsout;
}

sub WalkDirs(\@) {	# Traverse directories
	my @dirlist = @_;
	my @leftoverlist = ();
	$quickchek = 0;
	if ( $#dirlist > 0 ) {	# Sort dir elements here, 'cause we don't anywhere else
		if ($countsorts) { &SortNCount("(WalkDirs [dirlist])");}
		@dirlist = sort(@dirlist)
	}
	for my $delem (@dirlist) {
		if ($delem eq ".") {
			$sanitycount += 1;
			&ProcessLS(&RunLS());
			$sanitycount -= 1;
		} else {
			push(my @templist,&RunLS($delem));
			if ( $templist[0] !~ /^\Q$delem\E\/$/) { # Fix Traversal bug when dir name looks like regex (e.g.: /dir/named/c++/file.txt)
				$sanitycount += 1;
				&ProcessLS(@templist);
				$sanitycount -= 1;
				@templist = ();
			} else {
				push(@leftoverlist,@templist);
			}
		}
	}
	return @leftoverlist;
}

sub ProcessLS(\@) { # Determine element type for provided array (@_), and recurse as appropriate, sending result lists to &ProcessDirs()
	my @direlems;
	my @filelems;
	my @throwaway = ();
	$lastintype = "ls";
	my @inputlist = ();
	if ( (($#_ <= $safelstnum) && ($sanitycount <= $sanityctmax ))  || ($blindstat) || ($nofiles) || ($unlimistat) ) {
		for my $lelem (@_) {	# Separate input list into Files and Dirs (arrays)
			$lelem =~ s/\/$//g; # Because (-l) doesn't work if $lelem has / on the end
			if ($lelem !~ /^$/) {
				if (-d $lelem) { # (^ moved up) strip the last '/' before adding dir to array
					if ((($nosymtrav) || ($nolinks)) && (-l $lelem)) { # Test to see if dirs are symlinks, and if so, don't follow
						if ($nolinks) {
							push(@throwaway,$lelem); # Log the loss.
						} else {
							if ($linkid) {
								my $ltarget = readlink($lelem) || 'unknown';
								$lelem .= " -> $ltarget/";
							} else {
								$lelem .= " (->)";
							}
							push(@filelems,$lelem); # Enumerate, but do not traverse
						}
					} else {
						push(@direlems,$lelem);
					}
				} elsif (-f _ ) { # ('_' is cached data from $lelem above)
					if ((($testlinks) || ($nolinks)) && (-l $lelem)) {
						if ($nolinks) {
							push(@throwaway,$lelem); # Log the loss.
						} else {
							if ($linkid) {
								my $ltarget = readlink($lelem) || 'unknown';
								$lelem .= " -> $ltarget/";
							} else {
								$lelem .= " (->)";
							}
							push(@filelems,$lelem); # Enumerate, but do not traverse
						}
					} elsif ($nofiles) {
						push(@throwaway,$lelem); # Log the loss.
					} else {
						push(@filelems,$lelem);
					}
				} else { # Not a file or directory...
					if ($lelem eq "-") {
						push(@readlist,$lelem);
					} elsif ($nofiles) {
						push(@throwaway,$lelem); # Log the loss.
					} else {
						if (-e _ ) { # Special Devices?
							push(@filelems,$lelem);
						} elsif (-l $lelem ) { # lstat can't used cached _ from stat above
							if ($nolinks) {
								push(@throwaway,$lelem); # Log the loss.
							} else {
								print STDERR "Warning: Link with missing target '$lelem'.\n";
								if ($testlinks) {
									$lelem .= " (->)";
								}
								push(@filelems,$lelem);
							}
						} else {
							print STDERR "Can not determine element type for '$lelem'.\n";
						}
					}
				}
			}
		} # Now push data to @inputlist 
		if ((@direlems != 0) && (@filelems == 0)) { # Dirs, no files
			if (( $#direlems <= $safedirnum) || ($blindstat && ($sanitycount <= 2) ) || ($unlimistat) || ($nofiles)) {
				if ($sanitycount >= $sanityctmax ) {
					push(@inputlist,&RunLS(@direlems));
				} else {
					push(@inputlist,&WalkDirs(@direlems));
				}
			} else {
				push(@inputlist,@direlems);
			}
		} elsif ((@direlems == 0) && (@filelems != 0)) { # Files, no dirs
			if ($#filelems == 0) {
				if ((-f $filelems[0]) && (-r _ )) {
					if ((-T _ ) && ($quickchek)) { # Only check a file if it's given on the command line.
						push(@readlist,$filelems[0]);
					} else {
						push(@inputlist,$filelems[0]);
					}
				} else { # Only one (non-text) file in the list... Strange, but okay.
					push(@inputlist,$filelems[0]);
				}
			} else { 
				for my $felem (@filelems) {
					push(@inputlist,$felem);
				}
			}
		} elsif ((@direlems != 0) && (@filelems != 0)) { # Dirs and files
			if ((($#filelems + $#direlems < $safefilnum) && ($expanddirs)) || ($blindstat && ($sanitycount <= 2) ) || ($unlimistat) || ($nofiles)) {
				for my $felem (@filelems) { # Process files, and flush list...
					push(@inputlist,$felem);
				}
				&ProcessDirs(@inputlist);
				@inputlist = ();
				if ($sanitycount >= $sanityctmax ) { # ...then process dirs as appropriate
					push(@inputlist,&RunLS(@direlems));
				} else {
					push(@inputlist,&WalkDirs(@direlems));
				}
			} else { # That's all the further we're descending push everthing to the list
				for my $drelem (@direlems) {
					# Tag the directory so it can be treated as such later without recursing
					push(@inputlist,"$drelem//");
				}
				push(@inputlist,@filelems);
			}
		} else { # Nothing to process
			if (! @throwaway) {
				&AddSpec("Nothing to list.");
			} else { # report empty directory...
				my $dironly = "$throwaway[0] "; # There should be only one path in this array.
				$dironly =~ s/\/[^\/]*$/\//; # Give this the same format that RunLS gives an empty directory.
				push(@inputlist,"$dironly");
			}
		}
	} else { # We've already gone far enough forward the whole input list to processing.
		for my $lelem (@_) {
			push(@inputlist,$lelem);
		}
	}
	if (@inputlist) {
		&ProcessDirs(@inputlist);
	}
}

sub RangeCalc($) {	# Return list of frames in a sequence
	my @rvals = ();
	my $inc = 1;
	my @nums = split(/[:-]/,$_[0]);
	my $cnum;
	my $fcnum;
	my $pval;
	if (defined($nums[2])) {
		$inc = $nums[2];
	}
	if (defined($nums[1])) {
		$cnum = $nums[0];
		$pval = length($cnum);
		if ($cnum == $nums[1]) {
			push(@rvals,$cnum);
		} elsif ($inc == 0) {
			die "ERROR: $cnum =/= $nums[1], but Inc is $inc\n";
		} elsif ($cnum > $nums[1]) {
			print STDERR "WARNING: Range listed in reverse\n";
			while ($cnum >= $nums[1]) {
				$fcnum = sprintf("%${pval}.${pval}d",$cnum);
				push(@rvals,$fcnum);
				$cnum -= $inc;
			}
		} else {
			while ($cnum <= $nums[1]) {
				$fcnum = sprintf("%${pval}.${pval}d",$cnum);
				push(@rvals,$fcnum);
				$cnum += $inc;
			}
		}
	} elsif (defined($nums[0])) {
		push(@rvals,$nums[0]);
	}
	return(@rvals);
}

sub LSCunpack(@) {
	my @packdata = @_;
	my @newlist = ();
	for my $lin (@packdata) {
		if (($userintype =~ /^list$/) && ($lin =~ /^(.*)\[([\d]+[-:,]+[\d:,\-]*[\d]+)\](.*)/)) { # (will match for last [] range)
			my ($lscpre,$lscnum,$lscext) = ($1,$2,$3);
			for my $range (split(",",$lscnum)) {
				my @vals = &RangeCalc($range);
				for my $val (@vals) {
					push(@newlist,"${lscpre}${val}${lscext}");
				}
			}
		} elsif ($lin =~ /([-\w\.#\s()\/]*)\[([\d]+[-:,]+[\d:,\-]*[\d]+)\]([-\w\.#\s()\/]*)/) { # Had to add hashes (#) to match...
			my $lscpre = $1;
			my $lscnum = $2;
			my $lscext = $3;
			my @ranges = split(",",$lscnum);
			for my $range (@ranges) {
				my @vals = &RangeCalc($range);
				for my $val (@vals) {
					push(@newlist,"${lscpre}${val}${lscext}");
				}
			}
		} else {
			push(@newlist,$lin);
		}
	}
	return(@newlist);
}

sub GetList() {
	my $ldata;
	my $ltsiz;
	my $wcount = 0;
	my $readfil = $_[0];
	my $validld;
	my $llcdir = "";
	my $intype = $userintype;
	my $FH = "STDIN";
	my @gldata = ();
	my %glseen = ();
	if ($readfil) {
		if (! -T $readfil) {
			print STDERR "Warning: $readfil does not appear to be a text file.\n\n";
			return;
		}
		open(FH, "< $readfil") or die "Input ERROR: '$readfil' $!\n";
		$FH = "FH";
	}
	while (defined(my $lin = <$FH>)) {
		chomp($lin);
		push(@gldata,$lin);
	}
	if ($readfil) {
		close(FH);
	}
	if ($repacklsc) {
		@gldata = &LSCunpack(@gldata);
	}
	if ($unpackonly) {	# Useful for on-the-fly list commands...
		for (@gldata) {
			&AddSpec("${_}");
		}
		@gldata = ();
	}
	&AssignList(@gldata);
}

sub AssignList(@) {
	my $ldata;
	my $ltsiz;
	my $wcount = 0;
	my @indata = @_;
	my $validld;
	my $llcdir = "";
	my $intype = $userintype;
	my @gldata = ();
	my %glseen = ();
	for my $lin (@indata) {
		chomp($lin);
		$validld = 1;
		if ($douniq) {
			if (defined($glseen{$lin})) {
				$validld = 0;
			} else {
				$glseen{$lin} = $lin;
			}
		}
		if ($lin !~ /^[\s]*$/ ) { #Don't use empty lines, or lines with only whitespace
			if ($intype eq "guess") {
				if ($lin =~ /^[-ld][-r][-w].[-r][-w].[-r][-w].\s/) {
					$intype = "tar";
					if (! $usersfn) {
						$sfn = $defsfn;
					}
				} elsif ($lin =~ /^([Tt][Oo][Tt][Aa][Ll]\s+\d+[a-zA-Z]{0,1}|[-\.\w\s\/]+:)$/) {
					$intype = "ll";
					if (! $usersfn) {
						$sfn = $defsfn;
					}
				} elsif ($lin !~ /\s/) {
					$intype = "list";
				} else {
					$intype = "lastfield";
				}
			}
			if ($intype eq "list") { # Process output of find, ls, etc.
				$ldata = $lin;
			} elsif ($intype =~ /^(tar|ll)$/) { # Process tar output
				# We'll only process files, directories, and links for now...
				my @lins = split(/\s+/,$lin);
				if (! defined($lins[$sfn]) ) {
					$ltsiz = "0";
				} elsif ($lins[${sfn}] =~ /^[0-9]+$/ ) {
					$ltsiz = $lins[${sfn}];
				} else {
					$ltsiz = "0";
				}
				if ($lins[0] =~ /^-[-r][-w].[-r][-w].[-r][-w].$/) {
					$ldata = "${llcdir}$lins[$#lins]";
				} elsif ($lins[0] =~ /^l[-r][-w].[-r][-w].[-r][-w].$/) {
					$ldata = "${llcdir}$lins[$#lins - 2]";
				} elsif ($lins[0] =~ /^d[-r][-w].[-r][-w].[-r][-w].$/) {
					$ldata = "${llcdir}$lins[$#lins]";
					if ($ldata !~ /\/$/) {
						$ldata .= "/";
					}
				} elsif (($lins[0] =~ /^[Tt][Oo][Tt][Aa][Ll]$/) &&  ($intype eq "ll")) {
					$validld = 0;
				} elsif ($lins[0] =~ /^[-\.\w\s\/]+:$/) {
					if (($userintype ne "guess") && ($intype ne "ll")) {
						print STDERR "Confusing $intype output: $lins[0]\n";
					} else {
						if (($userintype eq "guess") && ($intype eq "tar")) {
							print STDERR "Switching \$intype to 'll'\n";
							if (! $usersfn) {
								$sfn = $defsfn;
								if ($dostat) { # We should only see this if the user did something like 'ls -l *'
									print STDERR "Files in local directory may not be evaluated properly for size.\n";
									print STDERR "Please use '-sf' to correct.\n";
								}
							}
							$intype = "ll";
						}
						$llcdir = $lins[0];
						$llcdir =~ s/:/\//;
						$llcdir =~ s/^\.\///;
					}
					$validld = 0;
				} elsif ($lins[0] =~ /^.[-r][-w].[-r][-w].[-r][-w].$/) { # Non-file/directory/link (special device?)
					$ldata = "${llcdir}$lins[$#lins]";
				} else {
					if (! $ignorerr) {
						print STDERR "Confusing $intype output: $lins[0]\n";
						if ($wcount > 9 ) {
							die("Too Many Errors.  Bailing\n");
						}
					}
					$validld = 0;
					$wcount += 1;
				}
			} else { # (lastfield)
				my @lins = split(/\s+/,$lin);
				if (($dostat && $usersfn)) {
					if (! defined($lins[$sfn]) ) {
						$ltsiz = "0";
					} elsif ($lins[${sfn}] =~ /^[0-9]+$/ ) {
						$ltsiz = $lins[${sfn}];
					} else {
						$ltsiz = "0";
					}
				}
				if ($userlfn) {
					$ldata = $lins[$lfn];
				} else {
					$ldata = $lins[$#lins];
				}
			}
			if ($validld) {
				if (($dostat) && (($intype =~ /^(tar|ll)$/) || (($usersfn) && ($intype =~ /^lastfield$/)) )) {
					push(@gldata,"$ldata>>>$ltsiz"); # Horrible hack to treat a scalar like an array
				} else {
					push(@gldata,$ldata);
				}
			}
			$ldata = $lin; # So we can check out the last line later...
		}
	}
	$lastintype = $intype;
	if (($#gldata == 0) && ($scheck)) {
		@gldata = split(/\s+/,$ldata);
	}
	if (($#gldata > 0) && (! $bansorts)) {
		if ($countsorts) { &SortNCount("(GetList)");}
		@gldata = sort(@gldata);
	}
	if (($lastintype eq "list") && ($doreaddir)) {
		&ProcessLS(@gldata);
	} else {
		&ProcessDirs(@gldata);
	}
}

sub ShowVersion() { # File sequence listing tool with compact sequence notation
	my @bpath = split /\//,$0;
	my $bfil = pop(@bpath);
	print STDOUT "\n$bfil: -\tFile Sequence Listing Utility\n\twith compact notation / expansion\n\nVersion $Revision\n\n";
	exit 0;
}

sub ShowHelp() { # Usage information:
	my @bpath = split /\//,$0;
	my $bfil = pop(@bpath);
	print STDOUT "\nUsage: $bfil [files] [dirs] [options]\n";
	print STDOUT "\t-n\tNormal sequence notation:\n";
	print STDOUT "\t\t\tpre.[0000-0010].ext\n\t\t\tpre.0014.ext\n\t\t\tpre.0016.ext\n\t\t\tpre.0018.ext\n\t\t\tpre.[0030-0031].ext\n";
	print STDOUT "\t-c\tCompact sequence notation:\t(default)\n\t\t\tpre.[0000-0010,0014-0018:2,0030,0031].ext\n";
	print STDOUT "\t-l\tLong sequence notation:\n";
	print STDOUT "\t\t\tpre.[0000-0010].ext\n\t\t\tpre.[0014-0018:2].ext\n\t\t\tpre.0030.ext\n\t\t\tpre.0031.ext\n";
	print STDOUT "\t-r\tRelaxed sequence notation:\n\t\t(Treat any two consecutive numbers incremented by 1 as a 'sequence')\n";
	print STDOUT "\t\t    (With '-l'):\n\t\t\tpre.[0000-0010].ext\n\t\t\tpre.[0014-0018:2].ext\n\t\t\tpre.[0030-0031].ext\n";
	print STDOUT "\t\t    (With '-c'):\n\t\t\tpre.[0000-0010,0014-0018:2,0030-0031].ext\n";
	print STDOUT "\t\t    ('-n' already has this behavior)\n";
	print STDOUT "\t-b\tBrief list output (with directories/sequences inline)\n";
	print STDOUT "\t-d\tDirectory list output (directory tag before sequence list) [default]\n";
	print STDOUT "\t-e\tExpand directories from returned mixed list\n\t\t\t(when [default] 10 or fewer entries are returned by readdir)\n";
	print STDOUT "\t-nl\tDo not traverse symbolic links to directories\n";
	print STDOUT "\t-s\tSupress listing of empty directories (that've been identified as such)\n";
	print STDOUT "\t-z\tUse file sizes for comparison (specified with 'sf' for command/list outputs)\n";
	print STDOUT "\t-lf \$n\tUse field \$n (starting from 0) as list field (containing data to sort)\n";
	print STDOUT "\t-sf \$n\tUse field \$n (starting from 0) as size field\n";
	print STDOUT "\t-p\tPrint sizes in human readable format (implies '-z', expects sizes in bytes)\n";
	print STDOUT "\t-ph\tPrint only human readable sizes, using those values for size comparison\n";
	print STDOUT "\t-force\tIgnore invalid entries from tar output\n";
	print STDOUT "\t-f \$fil\tRead file: \$fil as input (use '-' to explictly specify stdin)\n";
	print STDOUT "\t-ff\tTreat remaining files on command line as input files\n";
	print STDOUT "\t-t \$typ\tExplicitly specify input file as type: \$typ (tar|list|ll)\n";
	print STDOUT "\t-o \$fil\tSpecify optional file to write resulting ouptput.\n";
	if ($_[0]) {
		print STDOUT "\n\t[-]-strict\tNegate '-r' style relaxed sequence directive\n";
		print STDOUT "\t[-]-nostat\tNegate '-[z|p|ph]' size calculation\n";
		print STDOUT "\t[-]-readlist\tTreat input from stdin as a list of elements to process\n";
		print STDOUT "\t[-]-blindstat\tStat a directory's contents without checking number of entries.\n";
		print STDOUT "\t\t\t    This stats all entries, and causes all top level sub-directories\n";
		print STDOUT "\t\t\t    to be expanded, superceding the default limit of 100 entries!!\n";
		print STDOUT "\t[-]-unlimit\tStat all directory's contents without checking number of entries (recursive).\n";
		print STDOUT "\t[-]-framecount\tWhen using a sequence notation, list frame count in parenthesis\n";
		print STDOUT "\t[-]-sizfirst\tWhen listing file sizes, print size before file names\n";
		print STDOUT "\t[-]-sizlast\tWhen listing file sizes, print size after file names [default]\n";
		print STDOUT "\t[-]-sumsize\tWhen listing file sizes, print the sum of the sequence sections\n";
		print STDOUT "\t[-]-totalsize\tWhen listing file sizes, print the sum of the complete sequence \n";
		print STDOUT "\t[-]-sumtotal\tList a total count of all files found\n";
		print STDOUT "\t[-]-noparens\tWhen listing file sizes/counts, do not print values in parenthesis\n";
		print STDOUT "\t[-]-doparens\tWhen listing file sizes, print value in parenthesis [default]\n";
		print STDOUT "\t[-]-nospad\tDo not add space padding after listing single frames\n";
		print STDOUT "\t[-]-dospad\tPad spaces after single frames in sequences when orphaned [default]\n";
		print STDOUT "\t[-]-dirflags\tWhen listing un-recursed dirs, print a slash afterwards [default]\n";
		print STDOUT "\t[-]-nodirflags\tWhen listing un-recursed directories, do not print a trailing slash.\n";
		print STDOUT "\t[-]-dirspace\tWhen using directory list style, output newline even for empty dirs\n";
		print STDOUT "\t[-]-presort\tPre-Process file lists for unique patterns (non-delimited sequences,\n";
		print STDOUT "\t\t\t    congruent sequences with multiple extensions, etc.) [takes time]\n";
		print STDOUT "\t[-]-nopresort\tDon't Pre-Process file lists for unique patterns (may save time).\n";
		print STDOUT "\t[-]-np\t\tshort for -[-]nopresort\n";
		print STDOUT "\t[-]-skipsort|q\tDon't do any pre-sorting of readdir output (quick). This may save\n";
		print STDOUT "\t\t\t    time, but will not list non-sequenced files in any particular\n";
		print STDOUT "\t\t\t    order, so output can be messy.\n";
		print STDOUT "\t[-]-noskipsort\tNegates -[-]skipsort\n";
		print STDOUT "\t[-]-nosort\tDon't do any sorting of input data before sequence computing.\n";
		print STDOUT "\t[-]-debugsort\tKeep a tally of how many times sort is called during execution.\n";
		print STDOUT "\t[-]-uniq\tWhen reading from a list, skip duplicate entries.\n";
		print STDOUT "\t[-]-repack\tWhen reading in lsc list notation, re-pack the list (implies -uniq)\n";
		print STDOUT "\t[-]-unpack\tExpand lsc syntax input and print long list. (No further processing)\n";
		print STDOUT "\t[-]-nopack\tOutput a sorted list only (no sequence notation).\n";
		print STDOUT "\t[-]-invert\tOutput list containing frames not present for detected sequences.\n";
		print STDOUT "\t[-]-showlinks\tShow targets of symbolic links in output. (Assumes '-linkid')\n";
		print STDOUT "\t[-]-nolinks\tSuppress output of files/dirs that are symbolic links.\n";
		print STDOUT "\t[-]-nofiles\tSuppress output of all files.\n";
		print STDOUT "\t[-]-nodirlinks\tList symbolic links to directories, but to not traverse. [-nl]\n";
		print STDOUT "\t[-]-linkid\tShow targets of symbolic links.\n";
		print STDOUT "\t[-]-nolinkid\tDo not display targets of symbolic links, just notate '(->)'.\n";
		print STDOUT "\t[-]-imac\tIgnore files starting with '._' (Mac Resource Fork files)\n";
		print STDOUT "\t[-]-lex\t\$str\tIn list mode, exclude lines matching \$str from sequence sorting.\n";
		print STDOUT "\t[-]-padout\tPad fields such that output aligns spaces on the final column.\n";
		print STDOUT "\t\t\t    (up to \$maxlenval)\n";
		print STDOUT "\t[-]-cleanout\tDon't pad final field with spaces if it's left justified.  [default]\n";
		print STDOUT "\t[-]-rj [\$n]\tAttempt to right justify output to max of \$n columns [default 70].\n";
		print STDOUT "\t[-]-rjg [\$n]\tSame as -rj, except only grow max column value as data requires.\n";
		print STDOUT "\t[-]-lj [\$n]\tLeft justify output [default]\n";
		print STDOUT "\t[-]-ljf [\$n]\tLeft justify output, and grow to \$n columns [default 80]\n";
		print STDOUT "\t[-]-tld\t\tAttempt to sort a host list by top level domain, (subdomains, etc.)\n";
		print STDOUT "\t[-]-extnum\tGive sorting priority to numeric sequences in filename extensions.\n";
		print STDOUT "\t[-]-endnum\tGive sort priority to numeric sequences at the end of filenames.\n";
		print STDOUT "\t[-]-ipcheck\tWhen IP Addresses are encountered, sort them by last octet. [default]\n";
		print STDOUT "\t[-]-noipcheck\tWhen IP Addresses are encountered, ignore them for sorting.\n";
		print STDOUT "\t[-]-slv \$n\tUse \$n for max number of allowable entries returned by a primary\n";
		print STDOUT "\t\t\t    readdir where automatic checking is done for subdirectories to\n";
		print STDOUT "\t\t\t    recurse.  (defaults to $dsln) [Safe List Value]\n";
		print STDOUT "\t[-]-sfv \$n\tUse \$n for max number of allowable mixed (files and dirs) entries\n";
		print STDOUT "\t\t\t    returned by a primary readdir where subdirectories will be recursed\n";
		print STDOUT "\t\t\t    when '-e' is used.  (defaults to $dsfn) [Safe File Value]\n";
		print STDOUT "\t[-]-sdv \$n\tUse \$n for max number of allowable directories returned by readdir\n";
		print STDOUT "\t\t\t    that will be automatically recursed when no files are returned.\n";
		print STDOUT "\t\t\t    (defaults to $dsdn) [Safe Dir Value]\n";
		print STDOUT "\t[-]-sov \$n\tUse \$n for slv, sfv, and sdv values. [Safe Override Value]\n";
		print STDOUT "\t-pb\t\tNegate '-p[,h]' Human readable size display (implies -z)\n";
		print STDOUT "\t-1\t\tRead single line of input as file list, separated by whitespace.\n";
		print STDOUT "\t[-]-noprint\tProcess list, but don't print it (only debug messages if applicable)\n";
		print STDOUT "\t-license\tDisplay Software License.\n";
		print STDOUT "\t[-]-h[elp]\tDisplay [this]/brief help text\n\n";
		print STDOUT "\tThe default sequence notation encloses sequences or standalone numbers in square\n";
		print STDOUT "\tbrackets '[]', and separates discontinuous segments with commas ','.  If a sequence\n";
		print STDOUT "\tis found with an increment other than 1, a colon ':' is appended, followed by the\n";
		print STDOUT "\tincrement value.  For Example: [2-8:2] \n";
		print STDOUT "\t    (a sequence comprised of 2,4,6, and 8 (numbers 2 through 8 incremented by 2)\n\n";
	} else {
		print STDOUT "\t-lic\tDisplay Software License.\n";
		print STDOUT "\t[-]-h\tDisplay [verbose]/this help text\n\n";
	}
	exit 0;
}

sub ShowLicense() { # Copyright / License (Limit to 80 column output)
	print STDOUT "Copyright  2008-2013 Victor E. Vaile, IV. All Rights Reserved.\n\n";
	print STDOUT "Redistribution and use in source and binary forms, with or without modification,\n";
	print STDOUT "are permitted provided that the following conditions are met:\n\n";
	print STDOUT "1. Redistributions of source code must retain the above copyright notice, this\n";
	print STDOUT "   list of conditions and the following disclaimer.\n\n";
	print STDOUT "2. Redistributions in binary form must reproduce the above copyright notice,\n";
	print STDOUT "   this list of conditions and the following disclaimer in the documentation\n";
	print STDOUT "   and/or other materials provided with the distribution.\n\n";
	print STDOUT "3. The name of the author may not be used to endorse or promote products derived\n";
	print STDOUT "   from this software without specific prior written permission.\n\n";
	print STDOUT "THIS SOFTWARE IS PROVIDED BY THE AUTHOR \"AS IS\" AND ANY EXPRESS OR IMPLIED\n";
	print STDOUT "WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n";
	print STDOUT "MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\n";
	print STDOUT "SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n";
	print STDOUT "EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT\n";
	print STDOUT "OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n";
	print STDOUT "INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n";
	print STDOUT "CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n";
	print STDOUT "IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n";
	print STDOUT "OF SUCH DAMAGE.\n\n";
	print STDOUT "* That being said, if you find a bug, feel free to report it to the author. :)\n\n";
	exit 0;
}

sub ParseCommandLine() {
	if (defined($ARGV[0])) {
		while (defined($ARGV[0]) && "$ARGV[0]" !~ /^$/) {
			if ($ARGV[0] =~ /^-n$/) {
				$outpref = "normal";
				$nopack = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-c$/) {
				$outpref = "compact";
				$nopack = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-l$/) {
				$outpref = "long";
				$nopack = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?nopack$/i) { # NoPack
				$outpref = "nopack";
				$nopack = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(invert|missing)$/i) { # Invert List
				print STDOUT "Only listing frames missing from detected sequences\n";
				$invert = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-r$/) { # Relaxed Sequence Notation
				$relax = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?strict$/i) { # Undocumented negation of -r
				$relax = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-b(rief)?$/i) {
				$outstyl = "brief";
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-d$/) {
				$outstyl = "dircat";
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-e$/) { # Expand dirs with files < sfv
				$expanddirs = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(nl|nosymdir|nodirlinks)$/i) { # Don't expand symlinked dirs
				$nosymtrav = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?showlinks$/i) { # Don't expand symlinked dirs
				$nosymtrav = 1;
				$testlinks = 1;
				$linkid = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?nolinks$/i) { # Don't expand symlinked dirs
				$nolinks = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?nofiles$/i) { # Don't expand symlinked dirs
				$nofiles = 1;
				$nolinks = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(do)?linkid$/i) { # Expand symlink targets
				$linkid = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?nolinkid$/i) { # Don't expand symlinked targets
				$linkid = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?blindstat$/i) {
				$blindstat = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?unlimit$/i) {
				$unlimistat = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(do)?framecount$/i) {
				$framecount = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?noframecount$/i) {
				$framecount = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?size?first$/i) {
				$sizlast = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?size?last$/i) {
				$sizlast = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?noparens?$/i) {
				$doparens = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(do)?parens?$/i) {
				$doparens = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?nospad$/i) {
				$dospad = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(do)?spad$/i) {
				$dospad = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(do)?dirflags$/i) {
				$dirflags = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?nodirflags$/i) {
				$dirflags = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?dirspace$/i) {
				$dirspace = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?presort$/i) {
				$presort = 1;
				$skipsort = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?n(p|opresort)$/i) {
				$presort = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(q|(do)?skipsort)$/i) {
				$skipsort = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?noskipsort$/i) {
				$skipsort = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?nosort$/i) { # NoSort
				$bansorts = 1;
				$skipsort = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?debugsort$/i) { # DebugSort
				$countsorts = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?matchdebug$/i) { # Debug Matches
				$matchdebug = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?uniq(ue)?$/i) {
				$douniq = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?dup(licate)?$/i) {
				$douniq = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(do)?repack(lsc)?$/i) {
				$repacklsc = 1;
				$douniq = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?norepack(lsc)?$/i) {
				$repacklsc = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?unpack$/i) {
				$repacklsc = 1;
				$unpackonly = 1;
				$outpref = "nopack";		# <<<'cause we might've meant this
				$nopack = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(do)?imac$/i) {
				$imac = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?noimac$/i) {
				$imac = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(do)?ipcheck$/i) {
				$ipcheck = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?noipcheck$/i) {
				$ipcheck = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?padout$/i) { # PadOut
				$cleanout = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?cleanout$/i) { # CleanOut (Do not pad spaces after last output column)
				$cleanout = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?readlist$/i) { # ReadList
				$doreaddir = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-slv$/) {
				shift(@ARGV);
				if ((defined($ARGV[0])) && ("$ARGV[0]" =~ /^[0-9]+$/)) {
					$safelstnum = "$ARGV[0]";
				} else {
					print STDERR "-slv: $ARGV[0] is not a valid safe list value.\n";
				}
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-sfv$/) {
				shift(@ARGV);
				if ((defined($ARGV[0])) && ("$ARGV[0]" =~ /^[0-9]+$/)) {
					$safefilnum = "$ARGV[0]";
				} else {
					print STDERR "-sfv: $ARGV[0] is not a valid safe file value.\n";
				}
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-sdv$/) {
				shift(@ARGV);
				if ((defined($ARGV[0])) && ("$ARGV[0]" =~ /^[0-9]+$/)) {
					$safedirnum = "$ARGV[0]";
				} else {
					print STDERR "-sdv: $ARGV[0] is not a valid safe directory value.\n";
				}
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-sov$/) {
				shift(@ARGV);
				if ((defined($ARGV[0])) && ("$ARGV[0]" =~ /^[0-9]+$/)) {
					$safelstnum = "$ARGV[0]";
					$safefilnum = "$ARGV[0]";
					$safedirnum = "$ARGV[0]";
				} else {
					print STDERR "-sov: $ARGV[0] is not a valid safe override recursion value.\n";
				}
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-s$/) {
				$suppressmt = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-z$/) {
				$printsz = 1;
				$dostat = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?nostat$/i) { # negation of -z
				$dostat = 0;
				$printsz = 0;
				$sumcount = 0;
				$blindstat = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-sf$/) {
				shift(@ARGV);
				if ((defined($ARGV[0])) && ("$ARGV[0]" =~ /^[0-9]+$/)) {
					$sfn = "$ARGV[0]";
					$usersfn = 1;
				} else {
					print STDERR "-sf: '$ARGV[0]' is not a valid field number.\n";
				}
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-lf$/) {
				shift(@ARGV);
				if ((defined($ARGV[0])) && ("$ARGV[0]" =~ /^[0-9]+$/)) {
					$lfn = "$ARGV[0]";
					$userlfn = 1;
					$userintype = "lastfield";
				} else {
					print STDERR "-lf: '$ARGV[0]' is not a valid field number.\n";
				}
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-p$/) {
				$pnice = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-ph$/) {
				$pnice = 1;
				$ponly = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?sumsize$/i) {
				$sumsize = 1;
				$dostat = 1;
				$printsz = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?sumcount$/i) {
				$sumcount = 1;
				$framecount = 1;
				$sumsize = 1;
				$dostat = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?totalsize$/i) {
				$totalsize = 1;
				$dostat = 1;
				$printsz = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?sumtotal$/i) {
				$sumtotal = 1;
				$framecount = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-pb$/) { # Negate -p/-ph
				$pnice = 0;
				$ponly = 0;
				$printsz = 1; # implies -z
				$dostat = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-force$/) {
				$ignorerr = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-ff$/) {
				 $implyfiles = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-f$/) {
				shift(@ARGV);
				if (defined($ARGV[0]) && "$ARGV[0]" !~ /^$/) {
					if ($ARGV[0] =~ /^-h/) {
						&ShowHelp();
					}
					push(@readlist,$ARGV[0]);
					shift(@ARGV);
				} else {
					die("-f: No list file specified.");
				}
			} elsif ($ARGV[0] =~ /^-[Oo]$/) {
				shift(@ARGV);
				if (defined($ARGV[0]) && "$ARGV[0]" !~ /^(|-+.*)$/) {
					$outfile = $ARGV[0];
					shift(@ARGV);
				} else {
					die("-o: No output file specified.");
				}
			} elsif ($ARGV[0] =~ /^-lex$/) {
				shift(@ARGV);
				if (defined($ARGV[0]) && "$ARGV[0]" !~ /^$/) {
					$lexclude = $ARGV[0]; # (e.g.: $lexclude = " : ";)
					shift(@ARGV);
				} else {
					print STDERR "-lex: No exclusion string specified\n";
				}
			} elsif ($ARGV[0] =~ /^-t$/) {
				shift(@ARGV);
				if (defined($ARGV[0]) && "$ARGV[0]" !~ /^$/) {
					if ($ARGV[0] =~ /guess|tar|list|ll/){
						$userintype = $ARGV[0];
						if (($userintype eq "tar") && (! $usersfn)) {
							$sfn = 2;
						} elsif (($userintype eq "ll") && (! $usersfn)) {
							$sfn = $defsfn;
						}
					} else {
						print STDERR "-t: Unknown input file type ($ARGV[0]) specified.";
					}
					shift(@ARGV);
				} else {
					print STDERR "-t: No input file type specified.";
				}
			} elsif ($ARGV[0] =~ /^--?(do)?tld(sort)?$/i) {
				$tldsort = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?notld(sort)?$/i) {
				$tldsort = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(do)?extnum$/i) {
				$extnum = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?noextnum$/i) {
				$extnum = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(do)?endnum$/i) {
				$endnum = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?noendnum$/i) {
				$endnum = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?rj(g|f)?$/i) {
				$rjust = 1;
				if ($ARGV[0] =~ /^--?rj(g|f)$/i) {
					$growsprint = 1;
				} else {
					$growsprint = 0;
				}
				shift(@ARGV);
				if ((defined($ARGV[0])) && ("$ARGV[0]" =~ /^[0-9]+$/)) {
					$maxlenval = $ARGV[0];
					shift(@ARGV);
				}
			} elsif ($ARGV[0] =~ /^--?lj(g|f)?$/i) {
				$rjust = 0;
				if ($ARGV[0] =~ /^--?lj(g|f)$/i) {
					$growsprint = 0;
				} else {
					$growsprint = 1;
				}
				shift(@ARGV);
				if ((defined($ARGV[0])) && ("$ARGV[0]" =~ /^[0-9]+$/)) {
					$maxlenval = $ARGV[0];
					shift(@ARGV);
				}
			} elsif ($ARGV[0] =~ /^--?noprint$/i) {
				$doprint = 0;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?(do)?print$/i) {
				$doprint = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?h(elp)?$/i) {
				if (($ARGV[0] =~ /^--/) || ($ARGV[0] =~ /elp/i)) {
					&ShowHelp("Undoc");
				} else {
					&ShowHelp();
				}
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^--?v(ersion)?$/i) {
				shift(@ARGV);
				&ShowVersion();
			} elsif ($ARGV[0] =~ /^--?(copy|lic(ense)?)$/i) {
				shift(@ARGV);
				&ShowLicense();
			} elsif ($ARGV[0] =~ /^-1$/) {
				$scheck = 1;
				shift(@ARGV);
			} elsif ($ARGV[0] =~ /^-(-)*[a-zA-Z0-9]+$/) {
				print STDERR "Unknown Option: $ARGV[0]\n";
				&ShowHelp();
				shift(@ARGV);
			} else {
				if ($implyfiles) {
					push(@readlist,$ARGV[0]);
				} else {
					push(@lslist,$ARGV[0]);
				}
				shift(@ARGV);
			}
		}
		if (($tldsort) && ($nopack)) { # Use normal sort and unpack after TLD post sort
			$outpref = "compact";
			$nopack = 0;
			$tldunpk = 1;
		}
		if ($outpref =~ "nopack")  { # We do not print these valuse in nopack mode..
			$sumsize = 0;
			$totalsize = 0;
			$framecount = 0;
		}
		if (($pnice) && (! $sumcount)) { # Turn on printing of nomal size
			($printsz,$dostat) = (1,1);
		}
	}
}

# main()
&ParseCommandLine;

if ((@lslist != 0 ) || ( @readlist != 0 )) {
	if ( @lslist != 0 ) { # This one has to be first in case we're populating @readlist with a single value.
		if (! $bansorts) {
			if ($countsorts) { &SortNCount("(Main)");}
			&ProcessLS(sort(@lslist));
		} else {
			&ProcessLS(@lslist);
		}
	} 
	if ( @readlist != 0 ) {
		for my $plist (@readlist) {
			if ($plist ne "-" ) {
				if ($#readlist > 0) {
					push(@printarray,"\n###\n### $plist:\n###\n");
				}
				&GetList($plist);
			} elsif (! -t STDIN ) {
				&GetList();
			} else {
				print STDERR "STDIN: No input found.\n";
			}
		}
	}
} elsif (! -t STDIN ) {
	&GetList();
} else {
	push(@lslist,".");
	&ProcessLS(@lslist);
}

if (@printarray) {
	if ($tldsort) {
		@printarray = &ProcessTLD(@printarray);
	}
	if ($tldunpk) {
		@printarray = &LSCunpack(@printarray);
	}
	if ($doprint) {
		if ($framecount && $sumtotal) {
			if ($totalsize) {
				my $btf = &SizeFormat($runtotlsiz);
				@printarray = ("Total:\t$totalcount $btf",@printarray);
			} else {
				@printarray = ("Total:\t$totalcount",@printarray);
			}
		} elsif ($totalsize) {
			my $btf = &SizeFormat($runtotlsiz);
			@printarray = ("Total Size:\t$btf",@printarray);
		}
		&PrintSpec();
	}
}

exit $fullstat;

